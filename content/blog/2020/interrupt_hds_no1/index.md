---
title: "中断下半部-工作队列"
date: 2020-06-06T10:11:52+08:00
keywords: ["中断","工作队列"]
categories : ["中断机制"]
banner : "img/blogimg/workqueue.jpg"
summary : "工作队列（work queue）是另外一种将中断的部分工作推后的一种方式，它可以实现一些tasklet不能实现的工作，比如工作队列机制可以睡眠。"
---

### 中断下半部-工作队列

---

**本文包含那些内容？**

 - 工作队列和tasklet的区别
 - 中断上下文
 - 工作队列的使用；

**本文适合那些人阅读？** 

 - 想了解linuxer
 - 学习驱动开发的beginner
 - 学习内核模块编程beginner
 - 其他super linux NBer；

**参考书籍：**

  1. 《Linux内核设计与实现》
  2. 《Linux操作系统原理与应用》

---

#### 为什么还需要工作队列？

工作队列（work queue）是另外一种将中断的部分工作推后的一种方式，它可以实现一些tasklet不能实现的工作，比如工作队列机制可以睡眠。这种差异的本质原因是，在工作队列机制中，将推后的工作交给一个称之为工作者线程（worker thread）的内核线程去完成（单核下一般会交给默认的线程events/0）。因此，在该机制中，当内核在执行中断的剩余工作时就处在进程上下文（process context）中。也就是说由工作队列所执行的中断代码会表现出进程的一些特性，最典型的就是可以重新调度甚至睡眠。

对于tasklet机制（中断处理程序也是如此），内核在执行时处于中断上下文（interrupt context）中。而中断上下文与进程毫无瓜葛，所以在中断上下文中就不能睡眠。

因此，选择tasklet还是工作队列来完成下半部分应该不难选择。当推后的那部分中断程序需要睡眠时，工作队列毫无疑问是你的最佳选择；否则，还是用tasklet吧。



#### 中断上下文

在了解中断上下文时，先来回顾另一个熟悉概念：进程上下文（这个中文翻译真的不是很好理解，用“环境”比它好很多）。一般的进程运行在用户态，如果这个进程进行了系统调用，那么此时用户空间中的程序就进入了内核空间，并且称内核代表该进程运行于内核空间中。由于用户空间和内核空间具有不同的地址映射，并且用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行。这样就产生了进程上下文。

所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容。当内核需要切换到另一个进程时（上下文切换），它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态继续执行。上述所说的工作队列所要做的工作都交给工作者线程来处理，因此它可以表现出进程的一些特性，比如说可以睡眠等。

对于中断而言，是硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。因此处于中断上下文的tasklet不会有睡眠这样的特性。



#### 工作队列的使用

内核中通过下述结构体来表示一个具体的工作：

```c
struct work_struct
{
	unsigned long pending;//这个工作是否正在等待处理
	struct list_head entry;//链接所有工作的链表，形成工作队列
	void (*func)(void *);//处理函数
	void *data;//传递给处理函数的参数
	void *wq_data;//内部使用数据
	struct timer_list timer;//延迟的工作队列所用到的定时器
};
```

而这些工作（结构体）链接成的链表就是所谓的工作队列。工作者线程会在被唤醒时执行链表上的所有工作，当一个工作被执行完毕后，相应的work_struct结构体也会被删除。当这个工作链表上没有工作时，工作线程就会休眠。

通过如下宏可以创建一个要推后的完成的工作:

```c
DECLARE_WORK(name,void(*func)(void*),void *data);
```

也可以通过下述宏动态创建一个工作:

```c
INIT_WORK(struct work_struct *work,void(*func)(void*),void *data);
```

与tasklet类似，每个工作都有具体的工作队列处理函数，原型如下:

```c
void work_handler(void *data)
```

将工作队列机制对应到具体的中断程序中，即那些被推后的工作将会在func所指向的那个工作队列处理函数中被执行。

实现了工作队列处理函数后，就需要schedule_work函数对这个工作进行调度，就像这样：

```c
schedule_work(&work);
```

这样work会马上就被调度，一旦工作线程被唤醒，这个工作就会被执行（因为其所在工作队列会被执行）。

